# Estructuras Avanzadas Computacionales
### Universidad Autónoma de Aguascalientes
![Logo UAA](https://media.discordapp.net/attachments/1333954443875582042/1445895029615759381/image.png?ex=6932022e&is=6930b0ae&hm=173af517ea3a0c7c49511cd369e4633e7128841048695c5be87dbb55493f6248&=&format=webp&quality=lossless&width=1864&height=563)

[![Ver Proyecto Web](https://img.shields.io/badge/_Ver_Proyecto_Web-blueberrymauro.github.io-blue?style=for-the-badge&logo=github&color=3F5EFB)](https://blueberrymauro.github.io/Proyecto_28nov25/)

---

## 1. Portada
| Detalles | Información |
| :--- | :--- |
| **Materia** | Estructuras Avanzadas Computacionales|
| **Semestre** | $3^{\circ}$ (Agosto - Diciembre)|
| **Proyecto** | Final (Evaluación Parcial)|
| **Fecha de Entrega** | 4 de diciembre de 2025|

---

## 2. Integrantes y Roles

A continuación se detallan las responsabilidades asumidas por cada integrante, basadas en el historial de contribuciones y la división técnica del trabajo:

| Nombre del Estudiante | Rol Principal | Tareas y Contribuciones Principales |
| :--- | :--- | :--- |
| **Mauro Lomeli Muñoz** | Gestor de Proyecto y Líder de Interfaz | Estructura base del proyecto, diseño de interfaz y experiencia de usuario, sistema de animaciones en Canvas, gestión de ramas y solución de conflictos de fusión de código, integración de sonidos y estilos. |
| **Luis Fernando Silva Briones** | Lógica Central y Entrada Salida | Implementación de lógica de lectura y escritura de archivos de texto, desarrollo del motor de dibujo en Canvas, manejo de eventos de desplazamiento vertical y optimización de interacción visual. |
| **Juan Emmanuel Suarez Garcia** | Desarrollador de Algoritmos Estructurales | Desarrollo de algoritmos de verificación de Árbol y Bipartito, implementación de recorridos de profundidad y lógica de emparejamientos, coloración dinámica de nodos. |
| **Julio Davila Acevedo** | Desarrollador de Algoritmos de Optimización | Implementación de algoritmos de rutas cortas como Floyd Warshall y Bellman Ford y Árboles de Expansión Mínima como Prim y Kruskal, desarrollo de mensajes informativos emergentes. |
| **Erick Leonardo Chavez Ponce** | Soporte de Interfaz e Integración Lógica | Integración lógica para algoritmos bipartitos, funcionalidad de selección de nodos iniciales, ajustes de diseño adaptable a dispositivos en la vista principal y depuración de la interfaz visual. |

---

## 3. Metodología Usada
Para la gestión del proyecto se utilizó una metodología ágil adaptada:
* **Marco de trabajo:** Kanban.
* **Herramienta de Seguimiento:** Trello.
* **Control de Versiones:** Git y GitHub con manejo de ramas por funcionalidad y solicitudes de cambios.

---

## 4. Capturas del Tablero
*Evidencia de la organización y asignación de tareas mediante metodología Kanban.*

[![Ver en Trello](https://img.shields.io/badge/_Ver_en_Trello-proyecto28nov25-blue?style=for-the-badge&logo=trello&color=0079BF)](https://trello.com/b/WM8gfx30/proyecto28nov25)

![Tablero Kanban Trello](https://media.discordapp.net/attachments/1333954443875582042/1444065226570862693/image.png?ex=6931f18b&is=6930a00b&hm=f8c5f0162cdc66bec513ec831d89877a6749ed828b51632082cb9b467d9720f8&=&format=webp&quality=lossless&width=1785&height=748)

![Tablero Kanban Trello](https://media.discordapp.net/attachments/1333954443875582042/1445566674320490517/image.png?ex=69317920&is=693027a0&hm=e170803b02ade043aa40f4607dcca3d6659379439e67fa86d8ded036785a8059&=&format=webp&quality=lossless&width=1806&height=748)

![Tablero Kanban Trello](https://media.discordapp.net/attachments/1333954443875582042/1445891894293827697/image.png?ex=6931ff42&is=6930adc2&hm=90a89a74e4d3c1c92ea4b3391788f1cfd99fa2fc32eda8935ba828fa82e70bed&=&format=webp&quality=lossless&width=550&height=230)

---

## 5. Capturas y Enlaces del Repositorio
*Evidencia del flujo de trabajo y control de versiones.* <br>
[![Historial de Cambios](https://img.shields.io/badge/Historial_de_Cambios-commits-blue?style=for-the-badge&logo=github)](https://github.com/BlueberryMauro/Proyecto_28nov25/commits/main/)

![Historial de Cambios](https://media.discordapp.net/attachments/1333954443875582042/1445892341117489252/image.png?ex=6931ffad&is=6930ae2d&hm=04c162ddff5f8acaf4a86cc146dd2feb0504e0c33b33f062d95247ed405d3c70&=&format=webp&quality=lossless&width=1256&height=852) <br>
![Historial de Cambios](https://media.discordapp.net/attachments/1333954443875582042/1445905769160507587/image.png?ex=69320c2e&is=6930baae&hm=b36afd6d670280ef59104ceeadd4a76077be444e2c9499ed53a325b49927eafd&=&format=webp&quality=lossless) <br>
![Historial de Cambios](https://media.discordapp.net/attachments/1333954443875582042/1445906281310453860/image.png?ex=69320ca9&is=6930bb29&hm=27641f53b4002987bcfcab43793193fb592c3bcbe09fc3ed12c5d1ff5c1866be&=&format=webp&quality=lossless)
---

## 6. Algoritmos Implementados
El sistema permite la creación dinámica de grafos dirigidos, no dirigidos y ponderados, así como la ejecución de los siguientes algoritmos:

* **Recorridos:** Búsqueda en Anchura BFS y Búsqueda en Profundidad DFS.
* **Rutas Más Cortas:** Dijkstra, Bellman Ford y Floyd Warshall.
* **Árboles de Expansión Mínima:** Prim y Kruskal.
* **Propiedades Estructurales:** Verificación de Grafo Bipartito, Detección de Árbol y Emparejamientos.

---

## 7. Explicación Big-O por Algoritmo
*Análisis de complejidad temporal y espacial basado en la implementación mediante Matriz de Adyacencia.*

| Algoritmo | Tiempo $O(f(n))$ | Espacio $O(g(n))$ | Explicación Breve y Sustento Teórico |
| :--- | :---: | :---: | :--- |
| **BFS / DFS** | $O(V^2)$ | $O(V)$ | "La complejidad temporal de las operaciones BFS y DFS", (GeeksforGeeks, 2024) varía según la estructura de datos; al utilizar una matriz de adyacencia, para cada nodo visitado se debe iterar sobre toda su fila de vértices vecinos, resultando en una complejidad cuadrática. |
| **Dijkstra** | $O(V^2)$ | $O(V)$ | Se implementó mediante búsqueda lineal. Según explica Programiz (2024), el algoritmo mantiene un conjunto de vértices visitados y en cada iteración busca el nodo con menor distancia, lo cual en nuestra implementación matricial conlleva un costo cuadrático inevitable. |
| **Floyd Warshall** | $O(V^3)$ | $O(V^2)$ | Este algoritmo es eficiente para grafos densos, ya que (CP-Algorithms, 2023) afirma que requiere tres bucles anidados para evaluar todas las combinaciones posibles de nodos intermedios. El espacio es cuadrático para almacenar la matriz $D$. |
| **Bellman Ford** | $O(V \cdot E)$ | $O(V)$ | Relaja todas las aristas del grafo repetidas veces. Como indica Brilliant (2024), este método es capaz de manejar pesos negativos, pero "su complejidad es mayor que Dijkstra" (Brilliant, 2024), ya que recorre la estructura completa $V-1$ veces. |
| **Prim** | $O(V^2)$ | $O(V)$ | De manera similar a Dijkstra, busca el vértice de menor peso de conexión en cada paso. Según Jenkins (2023), la implementación "naive" (sin colas de prioridad binarias) iterando sobre el arreglo de distancias mínimas es la más adecuada para grafos densos representados en matrices. |
| **Kruskal** | $O(E \log E)$ | $O(V + E)$ | "El algoritmo de Kruskal ordena todas las aristas por peso", (GeeksforGeeks, 2023) y utiliza una estructura de conjuntos disjuntos (Union-Find) para verificar ciclos, siendo el ordenamiento el paso dominante en el tiempo de ejecución. |

---

## 8. Análisis y Discusión

Durante el desarrollo de este laboratorio de grafos, se observó que la elección de la estructura de datos fundamental, en este caso la **Matriz de Adyacencia**, influye directamente en la complejidad temporal. Como señala freeCodeCamp (2024), "las listas de adyacencia son mejores para grafos dispersos", (freeCodeCamp, 2024) mientras que nuestra elección de matriz penaliza el rendimiento en recorridos simples elevando su costo a $O(V^2)$, aunque facilita la verificación de conexiones en $O(1)$.

La visualización gráfica mediante el elemento Canvas de HTML5 presentó un desafío técnico significativo referente a la sincronización entre el estado lógico del algoritmo, como los nodos visitados o aristas resultantes, y su representación visual. Se optó por un sistema de renderizado que redibuja el grafo completo en cada ciclo de animación, permitiendo movimientos fluidos y retroalimentación visual inmediata como el coloreado de grafos bipartitos o el trazado de rutas críticas.

---

## 9. Conclusiones

El proyecto cumplió su objetivo de implementar y mostrar una biblioteca sólida de algoritmos de grafos. Con Kanban y Git el equipo pudo organizar el trabajo y unir sin contratiempos módulos que se desarrollaron en paralelo, como la parte de lectura de archivos y la lógica interna de los algoritmos. Durante el desarrollo se vio que la visualización interactiva funciona mucho mejor que el código estático para entender lo que pasa dentro de los algoritmos, especialmente en procesos que normalmente son difíciles de imaginar, como la relajación de aristas. También quedó claro que separar la lógica de dibujo de la lógica algorítmica fue fundamental para que el proyecto pudiera crecer sin desordenarse, permitiendo agregar más funciones sin romper nada. Al final, el equipo reforzó su comprensión sobre las limitaciones de tiempo y espacio de cada algoritmo y entendió mejor por qué algunas soluciones dejan de ser viables cuando se aplican a grafos realmente grandes, ya que su complejidad crece demasiado rápido para ser práctica.

---

## 10. Bibliografía

* Brilliant. (2024). *Bellman-Ford Algorithm*. Brilliant.org. Recuperado de https://brilliant.org/wiki/bellman-ford-algorithm/
* CP-Algorithms. (2023). *Floyd-Warshall Algorithm*. CP-Algorithms. Recuperado de https://cp-algorithms.com/graph/floyd-warshall.html
* freeCodeCamp. (2024). *Adjacency Matrix vs Adjacency List – Graph Data Structures Explained*. freeCodeCamp.org. Recuperado de https://www.freecodecamp.org/news/adjacency-matrix-vs-adjacency-list/
* GeeksforGeeks. (2023). *Kruskal’s Minimum Spanning Tree Algorithm*. GeeksforGeeks. Recuperado de https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/
* GeeksforGeeks. (2024). *Graph Data Structure And Algorithms*. GeeksforGeeks. Recuperado de https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/
* Jenkins, J. (2023). *Prim's Algorithm for Minimum Spanning Trees*. Baeldung on Computer Science. Recuperado de https://www.baeldung.com/cs/prims-algorithm
* Programiz. (2024). *Dijkstra's Algorithm*. Programiz. Recuperado de https://www.programiz.com/dsa/dijkstra-algorithm
* VisuAlgo. (s.f.). *Visualising Data Structures and Algorithms through Animation*. VisuAlgo.net. Recuperado de https://visualgo.net/en
* Universidad Autónoma de Aguascalientes. (2025). Estructuras computacionales avanzadas: Proyecto [Material de la asignatura]. Centro de Ciencias Básicas, Departamento de Ciencias de la Computación.